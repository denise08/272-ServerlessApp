# Serverless Web Application with AWS Lambda and DynamoDB
This application uses AWS Lambda, DynamoDB, and API Gateway to perform basic CRUD operations (Create, Read, Update, Delete) on the database. The DynamoDB database contains a table called StudentRecords. which holds information about students, such as the student id, name, and courses they are taking. The primary key for the database is the student id. The lambda function takes HTTP requests and performs the corresponding action on the database based on the type of request. API gateway was used to deploy the API and receive requests that would trigger the lambda function. As of now, the function handles creating table entries and reading from the table.

## Testing the application
For testing the application, `curl` was used to send HTTP requests to the deployed API Gateway. For testing the entry creation, the following command was ran: \
`curl -X POST https://<your-api-id>.execute-api.<region>.amazonaws.com/dev/students -H 'Content-Type: application/json' -d '{"student_id": "123", "name": "John Doe", "course": "Enterprise Software"}'` \
When successful, the console should output that the record was added successfully and could be verified when checking the DynamoDB dashboard.
![Screenshot 2024-09-08 at 12 09 10 AM](https://github.com/user-attachments/assets/eedd382d-0354-403c-9704-45336180085b)

For testing table entry retrieval, the following command was ran: \
`curl -X GET https://<your-api-id>.execute-api.<region>.amazonaws.com/dev/students?student_id=123` \
When successful, the console should output the table entry and its components. The following image shows example output of both of these cases:
![Screenshot 2024-09-08 at 12 08 11 AM](https://github.com/user-attachments/assets/e4ccb02f-0f94-4107-b7db-3044de5852d1)

## Reflection
Because this is my first experience with using AWS Lambda, DynamoDB, and API Gateway, one challenge I faced was to understand what each service did on its own and how they are able to interact with one another. Creating each component on its own seemed pretty straight forward but the major challenge I faced was setting up and connecting all the components together. When I was first testing my application through curl, I kept getting a KeyError from my lambda function code. For some reason, the “httpMethod” key was not present in the event structure and this part had confused me since through my research and tutorials, the httpMethod key should be present if a HTTP request was made. This was how the lambda function would process the event and then perform the corresponding action to DynamoDB. In my lambda function, I added code to debug this error by dumping what was in the event structure, and found that only the table entry components were passed in. No information regarding the HTTP request was added in. After some more research, I found that I needed to enable Lambda Proxy Integration for each method in the API. By enabling this, API Gateway would format the request into a JSON event object that Lambda could process, and this allowed my application to work as intended.

From this assignment, I learned more about what DynamoDB and Lambda functions were and its capabilities. Since an event needs to occur to trigger the code to be run, this feature allows users to only pay for what is used, rather than initially allocating a lot of resources in the beginning that may or may not be used. I can see how useful this could be as applications developed with these features could easily scale up or down depending on demand without having to estimate or manage the resources that are needed.
